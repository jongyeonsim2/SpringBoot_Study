
1. Rest API ( 2023.10.13 ) 
   1.1 정의 및 특징
       주고 받는 자원에 이름을 규정하고 URI에 명시해 HTTP 메소드
       (GET, POST, PUT, DELETE)를 통해 해당 자원의 상태를 주고 받는 것을 의미함.

       애플리케이션에서 제공하는 인터페이스를 의미하고, REST API는 REST 
       아키텍처를 따르는 시스템/애플리케이션 인터페이스를 나타냄.

       따라서, REST 아키텍처를 구현하는 웹 서비스를 'RESTful'라고 표현함.

       * 설계 규칙은 교재 27 페이지를 참고.
         

   1.2 종류
       - GET API
         웹 애플리케이션 서버에서 값을 가져올 때 사용하는 API

         - 어노테이션
           @GetMapping
             매개변수가 없는 메소드, 
             매개변수가 있는 메소드( 매개변수 하나, 쿼리스트링 )
           @PathVarialbe : 매개변수 하나
           @RequestParam : 쿼리스트링
           
           DTO(Data Transfer Object)
           - 쿼리스트링의 경우 좀 더 편하게 처리를 위한 방법.
             쿼리스트링의 키와 매핑됨.
           - GET, POST, PUT 에서도 사용.
           - VO(value object)와 구분해서 사용해야 함.
             값을 저장하되, 읽기전용(Read Only)로 설계해야 함.
             DTO 레이어(애플리케이션 내부 또는 외부)간의 데이터 교환에 사용함.

       - POST API
         웹 애플리케이션을 통해 데이터베이스 등의 저장소에 리소스를 저장시 사용.
         저장하고자 하는 리소스나 값을 HTTP body에 담아서 서버에 전달.

         @PostMapping
         @RequestBody : HTTP body 의 내용을 지정된 객체에 매핑하는 역할.
                        키와 값의 형태로 저장하기 위해 Map, DTO를 사용.

       - PUT API
         웹 애플리케이션 서버를 통해 데이터베이스 같은 저장소에 존재하는
         리소스 값을 업데이트하는데 사용.

         구현방법은 POST API와 거의 동일함. HTTP body 를 활용하게 됨.

         @PutMapping
         @RequestBody : HTTP body 의 내용을 지정된 객체에 매핑하는 역할.
                        키와 값의 형태로 저장하기 위해 Map, DTO를 사용.

       - DELETE API
         웹 애플맄테이션 서버를 거쳐 데이터베이스 등의 저장소에 있는 리소스를
         삭제할 때 사용.

         @PathVarialbe : 매개변수 하나
         @RequestParam : 쿼리스트링

2. Rest API 명세
       - 명세
         API가 어떤 로직을 수행하는지 설명하고 이 로직을 수행하기 위해서는
         어떤 값으 요청하며, 이에 따른 응답값으로 무엇을 받을 수 있는지 
         정리하는 자료임.

       - 라이브러리
         Swagger 를 사용.

       - configuration 설정
         pom.xml 필요한 라이브러리를 설정.
         설정 클래스를 작성.( SwaggerConfigurtation class )
         기본 package 경로를 설정. ( com.springboot.api 로 설정함. )
         따라서, com.springboot.api 하위의 모든 api를 scan 해서 문서를 작성함.

3. 로깅
       - 로깅(logging)
         애플리케이션이 동작하는 동안 상태나 동작 정보를 시간순으로 기록하는 것.
         개발영역 관점으로는 '비기능 요구사항'에 해당.(고객관점)

       - 라이브러리
         LogBack( logging framework )

       - configuration
         spring boot에서는 내장됨.

         레벨설정.( erroe, warn, info, debug, trace )
         상세한 레벨의 의미는 교재를 참조.(81 page)

         스프링 부트에서는 logback-spring.xml 의 설정 파일을 참조.
         Appender( console, file ) 를 추가 후, root 에서 지정해서 사용.
         각 Appender 에서 레벨, 출력 패턴 등을 설정.

       - 로그 출력(사용)
         Logback은 출력할 메세지를 Appender에게 전달할 Logger 객체를
         각 클래스에 정의해서 사용함.


  2. JPA ( 2023.10.16 ) 

     2.1 ORM( object-relational mapping, 객체관계매핑 )
         SQL 매핑 제품은 MyBatis 임. SQL 작성해서, SQL과 JAVA 코드를 분리.
         기능별로 XML 파일을 구분해서 SQL을 작성해서 관리.

         ORM은 자바의 객체와 데이터베이스를 연결하는 프로그래밍 기법임.(SQL 작성하지 않음)

         - ORM 의 장점과 단점
           - 장점
             - SQL을 직접 작성하지 않고 사용하는 언어로 데이터베이스에 접근할 수 있음.
             - 객체지향적으로 코드를 작성할 수 있기 때문에 비즈니스 로직에 집중할 수 있음.
             - 데이터베이스 시스템이 추상화되어 있기 때문에 MySQL에서 다른 데이터베이스로
               전환한다고 해도 추가로 드는 작업이 거의 없음.
               따라서, 데이터베이스 시스템에 대한 종속성이 줄어듬.
             - 매핑 정보가 명확하기 때문에 ERD 에 대한 의존도를 낮출 수 있고
               유지보수에 유리함.

           - 단점
             - 프로젝트의 복잡성이 커질수록 사용 난이도가 올라감.
             - 복잡하고 무거운 쿼리는 ORM으로 해결이 불가능한 경우가 있음.
             - SQL 튜닝이 정말 어려움.
               sql의 hint 절 사용이 어려움. => 벤더지향 기능을 ORM에 적용하기가 힘듬.

         - ORM 종류
           - JPA( Java Persistence API )
            자바 객체와 데이터베이스를 연결해 데이터를 관리함.
           - 하이버네이트
             JPA의 인터페이스를 구현. 내부적으로는 JDBC API를 사용함.

         - 중요한 개념
           - 엔터티
             데이터베이스의 테이블과 매핑되는 객체(자바 class).
             @Entity 어노테이션을 적용. @id 가 반드시 필요.( 1차 캐쉬에서 식별자로 사용됨. )

           - 엔터티 매니저( 생명주기와 구조가 중요 )
             프로젝트의 복잡성이 높아질수록 더욱 중요해짐.

             엔터티를 관리해 데이터베이스와 애플리케이션 사이에서 객체를
             생성, 수정, 삭제하는 등의 역할을 수행함.

             엔터티 매니저는 엔터티 매니저 팩토리(스레드 기반으로 동작)에서 만들어짐.
             request 별로 엔터디 매니저가 생성됨.

           - 영속성 컨텍스트
             엔터티 매니저는 엔터티를 영속성 컨텍스트에 저장해서 관리함.
             따라서, 영속성 컨텍스트는 엔터티를 관리하는 가상의 공간임.

             영속성 컨텍스트에는 1차 캐쉬, 쓰기 지연, 변경 감지, 지연 로딩 이라는 특징이
             있음.

             - 1차 캐쉬
               영속성 컨텍스트 내부에는 1차 캐쉬가 있음. ( Map 형태,키, entity, snapshot )
               캐쉬의 키는 엔터티의 @Id가 달린 속성이 기본키의 역할을 하는 식별자가 됨.

               엔터티를 조회를 하는 경우, 1차 캐쉬에서 데이터를 조회한 후,
               값이 있으면 반환을 하고, 값이 없으면, 데이터베이스에서 조회해서
               1차 캐쉬에 저장하고 반환을 함.

               따라서, 캐시된 데이터를 조회할 때는 데이터베이스를 거치지 않으므로,
               매우 빠르게 데이터를 조회할 수 있게됨.
                

             - 쓰기 지연
               쓰기 지연은 트랜잭션을 커밋하기 전까지는 데이터베이스에 실제로 질의문을
               보내지 않고, 쿼리를 모아두었다가 트랜잭션을 커밋하면 모아두었던 쿼리를
               한꺼번에 실행하는 것을 의미함.

               따라서, 적당한 묶음으로 쿼리를 요청할 수 이써 데이터베이스 시스템의
               부하을 줄일 수 있음.

             - 변경 감지
               트랜잭션을 커밋하면 1차 캐쉬에 저장되어 있는 엔터티의 값과 현재 엔터티의
               값을 비교한 후 변경된 값이 있다면 변경 사항을 감지해 변경된 값을
               데이터베이스에 자동으로 반영함.

               따라서, 쓰기 지연처럼 적당한 묶은으로 쿼리를 요청할 수 있고, 데이터베이스의
               부하를 줄일 수 있게됨.

             - 지연 로딩
               지연 로딩(lazy loading) 은 쿼리로 요청한 데이터를 애플리케이션에 바로
               로딩하는 것이 아니라 필요할 때 쿼리를 보내서 데이터를 조회하는 것을
               의미함.

               반대의 경우는 즉시 로딩임. 즉시 로딩은 조회할 때 쿼리를 보내 연관된
               모든 데이터를 가져오는 것음 의미함.

             상기의 특징들의 공통점은 모두 데이터베이스의 접근을 최소화해 성능을 높일 수
             있다는 점임. 캐쉬를 하거나, 자주 쓰지 않게 하거나, 변화를 자동 감지해서
             미리 준비하거나 하는 등의 방법을 이용하면 됨. 

             따라서, 이러한 특징을 이해하고 JPA를 사용하면 문제해결에 도움이 됨.

           - 엔터티의 상태
             엔터티는 4가지의 상태를 가짐.             

             - 분리 상태
               엔터티를 영속성 컨텍스트가 관리하고 있지 않는 상태.

             - 관리( 영속 ) 상태
               영속성 컨텍스트가 엔터티를 관리하고 있는 상태.

             - 비영속 상태
               영속성 컨텍스트와 관계가 없는 상태.

             - 삭제된 상태


             Member member = new Member(1L, "홍길동"); // 비영속 상태
             em.persist(member); // 관리 상태
             em.detach(member);  // 분리 상태
             em.remove(member);  // 삭제된 상태
               

    2.2 데이터베이스 ~ 애프리케이션 흐름
        
        애플리케이션 <-> 스프링 데이터 JPA or JPA <-> 하이버네이트 <-> JDBC <-> 데이터베이스

        스프링 데이터 JPA는 JPA를 사용하기 편하게 만들어 놓은 모듈임.


    2.3 학습시 참고사항
        - JPA는 학습 곡선이 매우 높음.
        - 따라서, JPA 의 핵심 개념들의 이해가 필수적임.
        - JPA가 어려운 근본적인 이유는  ORM 의 객체지향과 관계형 데이터베이스 라는
          두 가지를 모두 이해를 바탕으로 해야하기 때문임.
        - 추천하는 책
          자바 ORM 표준 JPA 프로그래밍, 저자 : 김영한, 총 페이지가 700 페이지 정도임.
          + 공식 기술 문서 + 데이터베이스 설계 기본서, 중급서


    2.4 엔터티 매니저 팩토리와 엔터티 매니저
        2.4.1 엔터티 매니저 팩토리
           엔터티 매니저 팩토리는 엔터니 매니저를 만들어주는 기능을 담당.

           엔터티 매니저 팩토리는 여러 스레드가 동시에 접근을 해도 안전하게 설계가 되어 있음.

           따라서, 엔터티 매니저 팩토리는 서로 다른 스레드간에 공유를 해도 되지만,
           엔터티 매니저는 여러 스레드가 동시에 접근하면 동시성 문제가 발생하게 됨으로,
           스레드간에 절대 공유를 하면 안됨.

           request 1 =>  WAS 1  => EntityManagerFactory 가 EntityManager 1 생성해줌. 
                     => Connection Pool 에서 connection 을 가져옴. => DB

           request 2 =>  WAS 1  => EntityManagerFactory 가 EntityManager 2 생성해줌. 
                     => Connection Pool 에서 connection 을 가져옴. => DB

        2.4.2 엔터티 매니저
           
           위의 정리된 내용 참고.


    2.5 영속성 컨텍스트
         - 영속성 컨텍스트는 엔터티를 영구 저장하는 환경임.
         - 엔터티 매니저로 엔터티를 저장하거나 조회를 하면 엔터티 매니저는 영속성 컨텍스트에는
           엔터티를 보관하고 관리를 함.

         - 엔터티의 생명 주기
           자세한 그림은 검색.

                            Detached

           New    ----->    Managed      <------> DB
                              
                            Removed

           - New ( 비영속 )
              
            Member member = new Member(); 
            member.setId();

            member는 영속컨텍스의 외부에 있는 상태임.

           - Managed( 영속 )

            em.persist(member);  => 영속 컨텍스트의 1차 캐쉬에 저장.
             
            member 는 영속컨텍스의 내부에 있는 상태임.

           - Detached( 분리, 준영속 상태 )

             em.detatch(member);

            member 는 영속컨텍스의 내부에서 분리된 상태임.

           - Removed( 삭제 상태 )

             em.remove(member)

             member 는 영속컨텍스느와 데이터베이스에서 삭제된 상태.

           - 영속성 컨텍스트( 메모리 공간 )의 특징
             - 영속성 컨텍스트와 식별자 값
               영속성 컨텍스트는 엔터티를 식별자 값으로 구분함.
               따라서, 영속 상태는 식별자 값이 반드시 필요하게 됨.
               식별자 값이 없으면 예외가 발생함.

               영속성 컨텍스트의 1 차 캐쉬는 Map 의 형태( key, value )로 생각하면 됨.
               1 차 캐쉬 형태는 @id, entity 임.

               member 를 관리하는 경우의 영속 컨텍스트 내부의 1차 캐쉬의 모양.

               @id              entity              snapshot
               'member1'        member1 entity      member1 entity 원본           <=>         DB
               'memver2'        member2 entity      member2 entity 원본           <=>         DB

               참고로, snapshot 항목은 entity 의 update 상태 유무를 판단하기 위한 것임.( 변경감지 )


             - 조회
               우선 1차 캐쉬에서 식별자 값으로 엔터티를 찾음.
               찾는 엔터티가 캐쉬에 없으면 엔터티 매니저는 데이터베이스를 조회하여 엔터티를 생성함.
               그리고, 1차 캐쉬에 저장한 후 영속성 상태의 엔터티를 반환하게 됨.

               영속 엔터티의 동일성
               Member a = em.find('member1');
               Member b = em.find('member1'); 

               System.out.println( a == b ); // 동일성 비교, 결과는 항상 true. (실제 인스턴스는 같다.)

               따라서, 영속성 컨텍스트는 성능상 이점과 동일성을 보장함.

              
               getById()
                  메소드 명에서 "get" 으로 시작. 검색한다는 의미보다는 가져온다는 의미가 있음.
                  해당되는 엔터티가 없으면 예외가 발생함.

               findById()
                  메소드 명에서 "find" 으로 시작. 검색한다는 의미가 있음.
                  실제 DB에 요청해서 엔터티를 가져옴.
                  영속성 컨텍스트의 1차 캐쉬를 먼저 확인 후, 엔터티가 없으면 실제 DB 에 데이터가 
                  있는지 확인.

                  결과적으로 entity 가 있는 경우와 없는 경우(null)가 발생함.
                  일반적으로 Optional 을 이용하여 null 처리를 함.



             - 등록
               엔터티 매니저는 트랜잭션을 커밋하기 직전까지 데이터베이스에 엔터티를 저장하지 않고,
               내부 쿼리 저장소인 쓰기 지연 SQL 저장소에 insert sql 을 계속해서 쌓아 저장함.

               트랜잭션이 커밋을 할 때 쓰기 지연 SQL 저장소에 저장된 쿼리들을 한꺼번에
               데이터베이스에 전송을 함. 

               이를 쓰기 지연이라고 함.

             - 수정
               커밋하기 전까지의 모든 SQL 은 쓰기 지연  SQL 저장소에 저장된 상태임.

               트랜잭션을 커밋하면 엔터티 매니저 내부에서 먼저 flush() 가 호출됨.
               엔터티와 snapshot 을 비교하여 변경된 엔터티를 찾음.
               변경된 엔터티가 있으면 update sql을 생성하여 쓰기 지연 SQL 저장소에 저장.
               쓰기 지연 SQL 저장소에 있는 SQL 을 데이터베이스에 전송함.
               데이터베이스 트랜잭션을 커밋함.

               그리고, JPA의 기본 전략은 엔터티의 모든 필드를 대상으로 update를 함.
               이유는 다음과 같음.

               모든 필드를 대상으로 update를 하게 되면 update sql 은 항상 동일하게 됨.
               따라서, 애플리케이션 로딩 시점에 update sql을 미리 생성해 두고 재사용이 가능하게 됨.

               또한 데이터베이스에 동일한 SQL을 보내면 데이터베이스는 이전에 한 번 파싱된 SQL을
               재사용 할 수 있게 됨.

               만약에, Update 대상 항목이 많은 경우는 수정된 데이터만 사용해서 동적으로
               SQL을 생성하는 전략을 선택하면 됨. => 하이버네이트의 확장 기능을 사용해야 함.
               하이버네이트의 공식 기술 문서를 참고. 


             - 삭제
               삭제의 경우도 바로 삭제가 되는 것이 아니라, 쓰기 지연 SQL 저장소에 SQL이 저장된 후
               트랜잭션의 커밋해서 엔터티 매니지의 flush() 가 호출하면 실제 데이터베이스에
               delete sql 을 전달하게 됨.

             - 플러시( flush )
               플러시(flush()) 는 영속성 컨텍스트의 변경 내용을 데이터베이스에 반영하는 기능임.

               플러시의 실행 단계는 다음과 같음.

               - 변경 감지가 동작해서 영속성 컨텍스트에 있는 모든 엔터티를 스냅샷과 비교해서
                 수정된 엔터티를 찾음. 수정된 엔터티는 수정 쿼리를 만들어 쓰기 지연 SQL 저장소에 저장함.
               - 쓰기 지연 SQL 저장소의 쿼리는 데이터베이스에 전송됨.( insert, update, delete sql )

               영속성 컨텍스트를 flush 하는 방법

               - 엔터티 매니저의 flush() 를 호출.
               - 트랜잭션 커밋 시 flush() 가 자동 호출.
               - JPQL 쿼리 실행시 자동으로 flush() 가 호출 됨.

             - 즉시 로딩과 지연 로딩
               - 즉시 로딩
                 엔터티를 조회할 때 연관된 엔터티도 함께 조회하는 것을 의미함. 어노테이션으로 설정함.
                 예)  em.find("member1") 을 호출 시, 회원 엔터티와 연관된 팀 엔터티도 함께 조회.

               - 지연 로딩
                 연관된 엔터티를 실제 사용할 때 조회함. 어노테이션으로 설정함.
                 프록시 객체는 주고 연관된 엔터티를 지연 로딩할 때 사용됨.

                 프록시 패턴( proxy pattern )
                 디자인 패턴중에 하나임.
                 특정 객체로부터의 "접근 제어"를 하는 대리인(객체)를 제공함.

                 예)  member.getTeam().getName() 에서 조회한 팀 엔터티를 실제 사용하는 시점에
                 JPA가 SQL을 호출하여 팀 엔터티를 조회하게되는 경우임.


  3. TEST ( 2023.10.17 )
     3.1 테스트의 정의
         작성한 코드나 비즈니스 로직을 테스트하기 위해 작성한 코드.

     3.2 테스트 종류 및 범위
         - 단위테스트(Unit Test)
           응용 프로그램에서 테스트 가능한 가장 작은 소프트웨어를 실행하여
           예상대로 동작하는지 확인하는 테스트임.  

         - 통합테스트(Intergration Test)
           단위 테스트보다 더 큰 동작을 달성하기 위해 여러 모듈들을 모아
           의도대로 동작하는지 확인하는 테스트임.

         - 시스템 테스트(System Test)
           단위 테스트가 끝나고 모듈 간의 인터페이스에 문제가 없는지의 통합 테스트까지
           완료하면, 시스템 전체가 정상적으로 작동하는지를 체크하는 테스트임.

         - 인수 테스트(Acceptance Test)
           소프트웨어의 인수를 목적으로 하는 테스트임. 소프트웨어를 인수하기 전에
           명세한 요구사항(인수조건) 대로 잘 작동하는지 검증하는 테스트임.

           앞선 테스트들과 달리 비즈니스 쪽에 초점을 두어서 실시함.
           프로젝트에 참여한 사람들(기획자, 고객, 개발자 등) 이 함께 테스트 시나리오를
           만들고, 개발자에 의해 테스트 코들를 작성해서 실시함
           

     3.3  테스트 이유(목적)
         - 개발 과정( 개발 중, 개발 후, 개발 전:TDD)에서의 문제점 발견()
         - 리팩토링의 범위 및 크기 등(리스크)이 줄어들게 됨
         - 애플리케이션의 가동을 통한 테스트보다 빠르게 진행이 가능.
         - 하나의 명세 문서로서의 기능 여할을 하게 됨.
         - 테스트를 통한 코드의 신뢰성을 확보할 수 있음.
         - 코드의 목적을 분형하게 나타낼 수 있어, 불필요한 코드의 추가를 방지할 수 있음.

     3.4  단위 테스트의 특징
         - 테스트 대상의 범위를 기준으로 가장 작은 단위의 테스트 방식임.
         - 일반적으로 메서드 단위로 테스트를 진행하게 됨.
         - 메소드의 호출을 통한 결과값을 확인하는 수준으로 테스트를 진행.

     3.5  테스트 코드 작성
         - Given-When-Then 패턴
           Given : 테스트에 필요한 환경을 설정.
           When : 테스트의 목적을 기술. 실제 테스트 코드가 포함되고 테스트 결과값을 확인.
           Then : 테스트의 결과를 검증. 일반적으로 When 의 결과값을 검증하는 작업을 수행.

     3.6  좋은 테스트 코드 작성을 위한 속성
          - Fast (빠르게)
            빠르게 테스트를 진행하지 않으면 코드의 품질이 저하되게 됨으로 빠른 테스트의 수행을 요구함.
          - Isolated(독립적)
            테스트 목적은 하나의 대상에 대해서만 수행되어야 함을 의미.
          - Repaeatable(반복 가능하게)
            어떤 환경에서도 반복 가능하도록 테스트 코드를 작성해야 함을 의미.
          - Self-Validating(자가 검증)
            테스트 자체만으로도 테스트의 검증이 완료되야 함의 의미.
          - Timely(적시)
            테스트하려는 애프리케이션 코드가 구현하기 전에 완성되어야 함을 의미.
            너무 늦게 작성된 테스트 코드는 정상적인 역할의 수행이 어려울 수 있어, 이를 고려해야 함의 의미.

     3.6 JUnit
          - 자바 언어에서 사용되는 대표적인 테스트 프레임워크임.
          - 어노테이션 기반의 테스트 방식을 지원함.
          - 단정문(assert)을 통해 테스트 케이스의 기대값이 정상적으로 나오는지 검토할 수 있음.
          - Junit는 크게 Jupiter, Platform, Vintage 의 세 가지 모듈로 구성이 됨.
          - Junit 의 생명주기
            @Test       : 테스트 코드를 포함한 메서드를 정의
            @BeforAll   : 테스트를 시작하기 전에 호출되는 메서드를 정의
            @BeforEach  : 각 테스트 메서드가 실행되기 전에 동작하는 메서드를 정의
            @AfterAll   : 테스트를 종료하면서 호출되는 메소드를 정의
            @AfterEach  : 각 테스트 메서드가 종료되면서 호출되는 메서드를 정의

     3.6 테스트 대상
          - Controller, Service, Repository 
            - 레이어별 독립적인 테스트를 위해서 Mock 객체를 활용함. 
              Mock 객체는 가짜 객체를 의미함.
            - 주요 어노테이션
              @WebMvcTest() 
                웹에서 사용되는 요청과 응답에 대한 테스트를 수행하게 됨.
                매개변수로 전달되는 대상 클래스만 로드해 테스트를 진행함.
              @MockBean
                실제 빈 객체가 아닌 Mock(가짜) 객체를 생성해서 주입하는 역할을 수행.
                해당 객체는 given() 메소드를 통해 동작을 정의함.
              @Test
                테스트 코드가 포함됨.

            - Controller 테스트 => 모킹 유닛 테스트로 테스트 케이스를 작성함.
            - service 및 repository => 순수 유닛 테스트로 테스트 케이스를 작성함.
              


          - 슬라이스 테스트라고도 함.
            슬라이스 테스트틑 레이어드 아키텍처를 기준으로 각 레이어별로 나누어
            테스트를 진행한다는 의미임.

          - 실습 테스트 내용 추가
            - Unit Test
              순수 유닛테스트, 모킹 유닛테스트( 중요함. )

            - Mock 을 사용하는 배경.
                만약 스프링 프레임워크 환경에서 서비스 레이어를 테스트 하고 싶을 때,
                가짜(mock) 객체가 없다면 의존성 주입 받고 있는 레포지토리부터 심지어는
                데이터베이스까지 구동을 해야함. 이렇게 하면 오히려 통합 테스트에 
                가까운 테스트를 하게 되어, 단위 테스트 범위를 벗어나게 됨.

                따라서, 단위 테스트시 모듈 간의 의존성을 끊고, 독립적인 테스트가 되도록 해야함.
                그래서, Mock 객체를 사용하게 되면, 모듈 독립성이 유지된 단위테스트가 가능해지게 됨.

                예로, MockMvc 는 가상으로 URL과 파라미터 등을 입력하여 브라우저에서
                사용하는 것처럼 실행할 수 있도록 되어 있어, 브라우저를 통한 실제 요청을 하지 않고도
                request 와 response 가 가능해서, Controller 를 독립적으로 단위 테스트를 할 수 
                있게 됨.

            - Mockito
              - mock 을 쉽게 만들고 mock 의 행동을 정의하는 stubbing, 정상적으로 작동하는지에 대한
                verify 등의 다양한 기능을 제공해주는 테스트 프레임워크임.
              - 단위 테스트를 위한 자바 Mocking 프레임워크 중에 하나임.

              - 활용 단계
                Mocking -> Stubbing -> Verifying

              - Mocking 
                테스트하고자 하는 코드가 의존하는 function 이나 class 에 대한 모조품을 만들어
                일단 돌아가게 하는 것을 의미함.
                한 마디로, 단위 테스트를 작성할 때, 해당 코드가 의존하는 부분을 가짜(mock) 으로
                대체하는 기법을 나타냄.
              - Stubbing
                Mock 객체의 행동을 조작하는 것을 의미함.

            - MockMvc
              Spring Test 에서 제공하는 MockMvc 는 웹 서버 없이 스프링 MVC의 동작을 테스트하기 위해 
              사용함.

     3.7 코드(테스트) 커버리지
         - 소프트웨어의 테스트 수준이 충분하지를 표현하는 지표 중의 하나임.
           테스트를 진행했을 때 대상 코드가 실행되었는지를 표현하는 방법으로 사용됨.
         - 보편적으로 사용되는 도구는 JaCoCo 임.
           Junit 테스트를 통해 애플리케이션의 코드가 얼마나 테스트가 되었는지를 보고서를 확인할 수 있음.
         - 구글의 코드 커버리지 가이드 라인
           커버리지 허용 비율 : 60%
           커버리지 권장 비율 : 75%
           커버리지 모범 비율 : 90%

           - 낮은 코드 커버리지는 넓은 코드 영역이 테스트되어 있지 않음을 보증한다.
           - 높은 코드 커버리지라고 해서 반드시 품질이 높은 것은 아니다.
           - 자주 업데이트 되는 코드는 커버를 해야 한다.
           - 레거시 코드의 커버리지 비율을 방치해도 문제는 없지만, 조금씩 커버리지 비율을
             높여가는 것이 좋다.


     3.8 테스트 주도 개발(TDD)
         - 반복 테스트를 이용한 소프트웨어 개발 방법으로 테스트 코드를 먼저 작성한 후
           테스트를 통과하는 코드를 작성하는 과정을 반복하는 소프트웨어 개발 방식임.
         - TDD 개발 주기 : 
           실패 테스트 작성 -> 테스트를 통과하는 코드를 작성 -> 리팩토링 을 반복함.
         - TDD 의 효과
           - 디버깅 시간 단축
             테스트 코드 기반으로 개발이 진행이 됨으로 문제가 발생했을 경우 발생한 문제점의 확인이 쉬움.
           - 생산성 향상
             반복된 테스트 코드를 통해 지속적으로 코드의 불안정성에 대한 피드백을 받기때문에
             리팩토링의 횟수가 점점 줄어들게 되어 생산성이 향상됨. 
           - 재설계 시간 단축
             테스트 코드를 조정하는 것으로 재설계 시간을 줄일 수 있음.
             테스트 코드 기반을 코드를 작성하기 때문임.
           - 기능 추가와 같은 추가 구현이 용이
             테스트 코드를 통해 의도한 기능을 미리 설계하고 코드를 작성함으로 목적에 맞는
             코드를 작성하는데 용이함.

     3.9 테스트 관련 참고 서적
         - 단위 테스트, 에이콘출판사, 2021년도 출판
         - 개발자를 위한 시프트-레프트 테스트, 제이펍, 2023년도 출판
         - 테스트 주도 개발 시작하기, 가메출판사, 2020년도 출판


  4. Spring Data JPA ( 2023.10.18 )
     4.1 Spring Data JPA
         JPA를 편리하게 사용할수 있도록 지원하는 스프링 하위 프로젝트임.
         JPA 에서 중요한 부분 ( 엔터티, 엔터티 매니저, 리포지토리(인터페이스) )
         - 엔터티를 생성 후 매핑방법 : @Entiy 를 이용해서 테이블과 매핑.
           클래스 객체는 테이블의 하나의 row에 해당됨.
           row 및 객체 식별을 위해서 @Id를 사용.
         - JpaRepository ( Spring Data JPA에서 제공 ) 인터페이스를 상속하여 
           인터페이스 리포지토리를 작성.

     4.2 쿼리 메소드
         ProductRepository 에 메소드 형태로 작성. => SQL 로 자동으로 변환됨.

         JpaRepository 에서 제공되는 기본 메소다는 식별자 기반으로 생성되기 때문에,
         필요한 기능에 따른 추가 SQL 문을 사용하기 위해서는 별도의 메소드를 재정의 해서
         사용해야 함.

         4.2.1 쿼리 메소드 작성방법

         find...By 형태의 메소드 명으로 작성.
         read...By
         get...By
         query...By
         search...By
         stream...By
         exists...By
         count...By
         delete...By
         remove...By

         is 
         (Is)Not
         (Is)Null, (Is)NotNull
         (Is)True, (Is)False
         And, Or

         (Is)GreaterThan, (Is)LessThan, (Is)Between
         (Is)StartingWith, (Is)EndingWith
         (Is)COntaining, (Is)Like

         정렬과 페이징
         정렬 : 메소드 쿼리의 메소드명에 Asc, Desc 를 사용.
                Sort 를 매개변수 사용.

         페이징 : Page, Pageable, PageRequest(Pageable 의 구현체) 를 사용.
                 PageRequest.of() 메소드를 활용하여 페이지 처리.            

     4.3 쿼리 어노테이션
         어노테이션을 이용항여 직접 SQL 문을 작성.
         @Query 어노테이션을 사용해서 SQL 문을 작성.
         @Param 어노테이션을 사용해서 SQL 문의 조건을 매개변수로 받도록 작성.

     4.4 QueryDSL
         DSL(Domain Specific Language, 도메인 특화 언어)
         쿼리메소드의 단점은 메소드 이름 기반으로 SQL을 작성하게 되어 한계가 있음.
         그리고, @Query 의 경우 직접 문자열로 SQL 을 작성하기 때문에,
         컴파일 시점에 에러를 잡지 못하고 런타임 에러가 발생할 수 있음.
         따라서, 개발 환경에서 문제가 없는 것처럼 보이다가 실제 운영 환경에서
         애프리케이션을 배포하고 나서 오류가 발생할 위험이 있음.
         이러한 단점을 해결하고 쿼리를 작성할 수 있도록 하는 것임.

         - QueryDSL 장점
           - 문법적으로 잘못된 쿼리를 허용하지 않음.
           - 동적으로 쿼리를 생성할 수 있음.
           - 코드로 작성하므로 가독성 및 생산성이 높음.
           - 도메인 타입과 속성을 안전하게 참조할 수 있음.
           - 개발환경에서 자동완성 기능을 사용가능.

         - QueryDSL 사용을 위한 Q 도메인 클래스 생성
           - MVN > LifeCycle > Compile 선택 
           - compile 성공 후, Target 폴더 > generated-sources > project package 
             QProduct 가 생성 확인.

         - QueryDSL 사용을 위한 클래스 및 인터페이스
           - JPAQuery, JPAQueryFactory 를 사용. ( 가져다 사용 )
           - QueryDSL config 클래스 생성. ( 클래스 작성 )
             매번 JPAQueryFactory를 초기화하지 않고 스프링 컨테이너에서 가져와서 사용할 수 있음.
           - QuerydslPredicateExecutor 인터페이스 활용.
           - QuerydslRepositorySupport 추상 클래스 활용.
             Product Domain(Entity, Table)

             기존의 ProductRepository 대신에 별도의 패키지에 ProductRepository 를 작성.

             ProductRepository JpaRepository 를 상속받아서 사용.
             + QuerydslRepositorySupport(QueryDSL 을 사용하기 위해 상속.)

             ProductRepository 에서 ProductRepositoryCustom 를 상속
             ProductRepositoryCustom 에서 메소드 작성
             ProductRepositoryCustomImpl  에서 QuerydslRepositorySupport 를 상속
                                          에서 메소드 구현

     4.5 JPA Auditing
           - 엔터티의 공통적으로 사용될 속성에 대해서 자동으로 값을 주입하는 기능.
           - Product Entity 의 데이터 생성일(createdAt), 데이터 수정일(updatedAt) 에 대해서
             별도의 entity 로 만들어서 재사용을 하는 것.
           - JPA Auditing을 사용하기 위하 설정 클래스 작성
             Product Entity의 공통 Entity 를 작성.


  5. 연관 관계 매핑 ( 2023.10.19 )
     5.1 연관 관계 매핑
         - customer table(고객), order table(주문)
           데이터베이스에서의 관계 설정 : FK(Foreign Key, 외래키)

           customer.cusId(고객 ID) 가 Order table 의 FK 가 되어서 테이블간 관계를 설정.

           테이블 간의 참조 관계
           customer table       order table
           custId               orderId
           custName             productId
                                custId

           엔터티 간의 매핑 관계(단방향)
           customer entity      order entity
           custId               orderId
           custName             productId
                                customer

           엔터티 간의 매핑 관계(양방향)
           customer entity      order entity
           custId               orderId
           custName             productId
           order                customer

         - 방향성
           - 단방향
             한 쪽 엔터티만 참조
           - 양방향
             두 엔터티가 서로 참조

         - 연관 관계 유형
           어떤 엔터티를 기준으로 관계된 엔터티를 보느냐에 따라 관계 유형이 달라짐.
           - 일대일
             @OneToOne

           - 일대다
             @OneToMany

           - 다대일
             @ManyToOne

           - 다대다
             @ManyToMany

           - 관계의 주인 설정.
             - mappedBy 를 사용하여 관계의 주인을 설정
             - mappedBy 는 관계의 주인이 아닌 쪽에 사용.
             - mappedBy value 는 관계의 주인쪽에 참조변수 명을 설정.

           - 관계의 주인 설정의 목적.
             관계의 주인을 설정하지 않으면, 관계가 설정되 양쪽 모두에 FK 가 생성이 되게됨.
             따라서, 불필요한 outer join 이 만들어지게 되는 비효율적인 상황이 만들어짐.
             그래서, FK 는 한쪽에만 만들어 지도록 해야함.

             @JoinColumn 을 이용하여 FK을 이름을 지정하지 않으면, 자동으로 만들어지 되어서,
             관리하기가 어려울 수 있음.

             관계를 설정시 일대일 관계에서는 각각에 참조할 객체의 타입으로 각각 멤버변수를 작성하고,
             관계가 다에 해당하는 경우는 참조할 정보를 List 형태로 멤버변수를 작성.


  6. 유효성 검사와 예외처리 ( 2023.10.23 )
     6.1 스프링 부트에서의 유효성 검사
         - 전송된 데이터에 대한 유효성 검사, DTO를 기반으로 검사를 수행.
         - 검사는 validaion용 어노테이션을 DTO의 멤법변수에 설정해서 검사를 수행.
         - 다양 어노테이션을 지원( p.296 ~ 298)

     6.2 @Validated ( 유효성 검사의 그룹핑 기능 )
         - 유효성 검사를 그룹으로 묶어 대상을 특정할 수 있는 기능.(마커 인터페이스)
         - 내부 코드는 없이 인터페이스만 작성.( 이름만 있음. )
         - 유효성 검사 어노테이션의 groups 속성에 적용.
         - 컨트롤에서 @Validated를 사용해서 어떤 그룹으로 유효성 검사를 수행할지를
           지정.

         - 동작기준
           - @Validated 어노테이션에 특정 그룹을 지정하지 않은 경우,
           groups 가 설정되지 않은 필드에 대해서 유효성 검사를 수행.
           - @Validated 어노테이션에 특정 그룹을 지정한 경우에는
           그룹으로 설정된 필드에 대해서만 유효성 검사를 수행.

     6.3 사용자(커스텀) Validation
         - 스프링에서 제공하는 것으로 부족한 경우 직접 작성해서 적용.
         - ContraintValidator 인터페이스를 구현해야 함.

     6.4 예외처리
         
         - 구분되는 예외 클래스로 크게 Checked Exception, Unchecked Exception 이 있음.
           Checked Exception 컴파일 단계, Unchecked Exception 런타임 단계
           Exception 을 상속하면 Checked Exception 이 됨.
           RuntimeException 을 상속하면 모두 Unchecked Exception이 됨.
         - 예외처리방법
           - 예외 복구
             try...catch...
           - 예외 처리 회피
             예외를 처리를 위임하는 경우. throw 키워드 사용.
             예외가 발생한 메소드를 호출한 곳에서 에러를 처리할 수 있도록 전가하는 방법.
           - 예외 전환( 교재에서의 실습 대상 )
             예외 복구 + 예외 처리 회피

             스르링 부트에서 처리하는 방법
             - (Rest)ControllerAdvice 와 @ExceptionHandler 을 통한 모든 컨트롤러 예외 처리
              글로벌 예외처리
             - @Exception 을 통한 특정 컨트롤러의 예외 처리

     6.5 사용자(커스텀) 예외
         - 장점
           - 예외 네이밍에 개발자의 의도를 담을 수 있어 이름으로만으로도
           예외 상황을 파악할 수 있음.
           - 애플리케이션에서 발생하는 예외를 개발자가 직적 관리할 수 있음.
           - 커스텀 예외를 사용하면 예외 상황에 대한 처리가 용이함.


  7. 액추에이터
     7.1 액추에이터란
         HTTP 엔드 포인트나 JMX 를 활용해 애플리케이션을 모니터링하고 관리하는 기능을 제공.

     7.2 엔드 포인트
         - 애플리케이션의 모니터링을 사용하는 경로.
         - 기본 엔트포인트 리스트(p.332 참조)
         - 엔드 포인트 관리 및 설정등은 application.propertes 에서 관리.

         - 엔드 포인트 예
           /info, 애플리케이션 기본 정보 확인
           /health, 애플리케이션 상태 확인
           /beans, 스프링 컨테이너에 등록된 스프링 빈의 전체 목록 표시
           /conditions, 자동설정 내역 확인
           /env, 스프링 환경변수 정보 확인
           /loggers, 로깅 레벨 확인

         - 애플리케이션 상태(/health)
           - UP
             애플리케이션이 작동죽이고 접근이 가능.
           - DONW
             애플리케이션이 작동하지 않거나, 접근할 수 없음.
           - UNKNOWN
             애플이케이션의 상태가 분명하지 않음.
           - OUT_OF_SERVICE
             애플리케이션이 접근할 수 있지만, 현재는 사용 불가.

         - 액추에이터 커스텀 기능 생성
           - 기존 기능에 내용을 추가하는 방법
           - 새로운 엔트 포인트를 개발하는 방법

  8. 서버간 통신
     8.1 RestTemplate
         - 동기 방식, 커넥션 풀을 지원하지 않음.
           TCP통신시 Time_Wait 에서 문제가 발생할 가능성이 있음.

           client                             Server
            1. close() 함수 호출
               FIN_WAIT1      ->   FIN ->      클라이언트 접속 종료 확인
                                              CLOSE_WAIT
                                               클라이언트에게 접속 종료 신호를
                                               받았다고 보냄.
               FIN_WAIT2    <-    ACK  <-
                                               LAST_WAIT
                                               socket 을 close()하고
                                               클라이언트에게 FIN 을 보냄.
              TIME_WAIT       <-     FIN   <-
              FIN을 받고
              클라이언트가 서버의
              socket close를
              인지했다고 ACK를 전송후
              TIME_WAIT로 상태 변경
                            ->        ACK ->    클라이언트가  socket close 한
                                               사실을 인지 후 완전히 연결을 종료
                  60초 후 CLOSE                 CLOSE


         - RestTemplate 커스텀 설정
           커넥션 풀을 사용하기 위함.

           HTTPClient 를 사용해서 커넥션 풀을 설정. => TIME_WAIT 이후의 재전송을 위한 시간에 대한 지연을 없앨 수 있음.
           - HTTPClient 를 이용한 커넥션 풀 설정 방법
             - HttpClient, HttpClientBuilder.create().
             - CloseableHttpClient, HttpClients.custom().
               Apache HttpClient 4.3 이상에서 추가됨.
               HttpClient 를 개선한 클래스임.
               CloseableHttpClient 의 사용을 권고.
             - 커넥션 풀 설정 정보(메소드로 제공)
               setMaxConTotal() : 최대 커넥션(세션이 확립) 수
               setMaxConPerRouter() : IP:Port 별 연결 수

           - RestTemplate에 커넥션 풀 설정하는 방법
             - HttpComponentsClientHtttpRequestFactory : RestTemplate의 생성자의 매개변수
             - HTTPClient : 커넥션 풀 설정 후 HttpComponentsClientHtttpRequestFactory에 설정.
             - RestTemplate에 HttpComponentsClientHtttpRequestFactory 를 생성자에 전달.

           
     8.2 WebClient( 기술적으로 좀 더 중요 )
         - 비동기 방식
         - 동기 방식으로 처리할 수 있는 메소드를 제공.
         - Spring WebFlux(흐름, stream) 에서 제공.

         8.2.1 WebFlux
           - client, server 에서 reactive(front-end 아님) 스타일의 애플리케이션 개발을 도와주는 스프링 모듈.
           - Spring WebMvc 를 대체할 수 있는 웹 프레임워크.
             Spring WebMvc 는 Servlet API 를 기반으로 구축된 웹 프레임워크.
           - WebMvc
             - Spring MVC는 기본적으로 블럭킹이고 동기방식을 사용.
             - 사용자의 요청이 들어올 때 마다 Thread 를 생성하여 처리.
             - 보통은 요청 시 마다 스레드를 생성, 삭제해주면 일정한 리소스가 지속적으로 소모가됨.(성능에 영향)
               그래서, Thread Pool을 생성해서 사용.
             - request 가 들어오면 그 요청을 Queue에 쌓고 순서에 따라서 Thread 를 하나 점유해 요청을 처리하게 됨.
             - 따라서, 동시 다발적으로 스레드 수 를 초과하는 요청이 발행하면 계속해서 Queue에 대기하게 되는
               Thread Pool Hell 현상이 발생하게 됨.
           - WebFlux
             - request 요청을 처리하는 방식은 Event-Driven 방식이고, 논 블러킹 방식임.
             - 요청이 처리될 때 까지 기다리지 않기 때문에 Spring MVC에 비해 사용자의 요청을 대량으로 받아낼 수 있음.
             - 따라서, 서버 프로그램이 효율적으로 동작을 하게 됨에 따라, cpu, thread, memory 등의 자원에 대한
               낭비가 발생하지 않고, 효율적으로 동작하는 고성능의 웹 애플리케이션을 개발하는 목적이 있음.
             - 이러한 내용으로 서비스간의 호출이 많은 마이크로 서비스 아키텍처에서 적합하다고 함.
             - 작은 양의 스레드와 최소한의 하드웨어 자원으로 동시성을 제어하기 위해 만들어짐.

         8.2.2 리액티브 프로그래밍(Reactive Programming)
             - 데이터 스트림과 변경 사항 전파를 중심으로하는 비동기 프로그래밍 패러다임임.(위키피디아)
             - 프로그래밍 언어로 정적 또는 동적인 데이터 흐름을 표현할 수 있어야 하며, 데이터 흐름을 통해
               하부 실행 모델이 자동으로 변화를 전파할 수 있는 것을 의미한다.(위키피디아)

             - 리액트 프로그래밍이란 변화의 전파와 데이터 흐름과 관련된 선언적 프로그램밍임.
             - 데이터 스트림을 이용하여 데이터를 전달하고, 데이터의 변경 시점을 이벤트로 하여
               수신자와 송신자 사이에 데이터를 전달시키는 비동기 프로그래밍임.

             - 장점
               간결해진 Thread 사용, 간단한 비동기 연산, 콜백 지옥의 제거

         8.2.3 리액터 라이브러리(Reactor Library)
             - Pivotal 의 오프소스 프로젝트임. JVM 위에서 동작하는 Non-Blocking 애플리케이션을 만들기 위한
               Reactive 라이브러리임.

         8.2.4 Block VS Non-Block
             - Block 방식은 호출자가 함수를 호출하게되면,
               호출된 함수에 제어권이 이동되면서, 함수의 로직을 처리하게 되고,
               제어권을 가지고 있는 함수가 결과를 반환할 때 까지 제어권을 가지고 있는 상태에서,
               제어권과 결과값을 함께 전달하는 것임.

             - Non-Block 방식은 똑같이 함수를 호출하면서 제어권을 호출되는 함수에게 넘기지만,
               Non-Block 방식은 이 제어권을 결과값이 나올 때 까지 가지고 있지 않고,
               호출된 함수가 바로, 호출자에게 제어권을 다시 넘기는 방식임.
               따라서, 호출자는 결과를 기다리지 않고 다음 함수에게 제어권을 넘기면서,
               제어권이 결과와는 의미가 없는 방식임.

             - 따라서, 블록과 논블록은 제어권의 관점에서 바라본 것임.

         8.2.5 WebClient
             - 웹으로 API를 호출하기 위해 사용되는 Http Client 모듈 중의 하나임.
             - RestTemplate 을 대체하는 Http 클라이언트임.
             - 기존의 동기 API를 제공할 뿐만 아니라, 논블로킹, 비동기 접근 방식을 지원함으로
               효율적인 통신이 가능함.

             - RestTemplate 과 WebClient
               두 client module 의 차이점은 RestTemplate 은 Multi-Thread와 Blocking 방식이며,
               WebClient 는 Single-Thread 와 Non-Blocking 방식임.

               Non-Blocking 방식은 네트워크의 병목 현상을 중이고 성능을 향상시킬 수 있어,
               Spring WebClinet 를 사용하면 요청자와 제공자 사이의 통신을 좀 더 효율적인
               Non-Blocking 방식으로 진행할 수 있다는 장점이 있음.

             - RestTemplate 의 동작 과정
               - Multi-Thread와 Blocking 방식임.
               - 1. Thread Pool 은 애플리케이션 구동시 설정된 만큼의 Thread 를 미리 생성해 둠.
                 2. Request 는 먼저 Queue 에 쌓이게 되고 가용한 Thread 가 있으면 그 Thread 를 할당하여 처리됨.
                 3. 따라서, 1 Request 당 1 Thread 가 할당됨.
                 4. 각 Thread 에서는 Blocking 방식으로 처리되어 응답이 올 때까지 그 Thread 를 
                   다른 Request 에 할당될 수 없음.

             - RestTemplate 의 단점.
               Request 를 처리할 Thread 가 Thread Pool 에 충분히 있다면 문제가 없겠지만,
               Thread 가 모두 사용된 이후의 Request 는 Queue 에 대기하게 됨.
               대부분의 문제는 네트워킹이나 DB 와의 통신에 문제가 생기기 때문에 Lock 이나 병목현상이
               일어나게 되면, 가용 가능한 Thread 수가 현저하게 줄어들기 때문에,
               전체 서비스가 매우 느려지는 결과로 이어지게 됨.

             - WebClient  의 동작 과정
               WebFlux 탄생 동영상 참조
               https://youtu.be/fYfNd6hqxu8

               - 1. 각 Request 는 Event Loop 내에 Job 으로 등록됨.
                 2. Event Loop 은 각 Job 을 제공자에게 요청한 후 결과를 기다리지 않고 다른 Job 을 처리함.
                 3. Event Loop 은 제공자로부터 callback 으로 응답이 오면 그 결과를 요청자에게 제공함.

               - Reactive Stream
                 리액티브 스트림은 비동기/노블로킹 처리를 위한 스트림 기반의 프로그래밍 모델임.
                 데이터 생산자와 소비자 사이에서 백프레셔를 지원해 데이터의 흐름을 제어할 수 있고,
                 이는 병목현상이나 예기치 못한 소프트웨어의 정지를 방지하게 됨.

                 자바 9에서부터 리액티브 스트림 API 로 JVM 환경에서 표준화가 되었고,
                 Flow 클래스를 통해 기본적으로 사요알 수 있게 되었음.

                 - 중요한 용어
                   - Publisher
                     데이터를 생성해 Subscriber 에게 전달하는 역할을 하는 생산자 인터페이스
                   - Subscriber
                     Publisher 로부터 데이터를 전달받아 처리하는 소비자 인터페이스
                   - Subscription
                     Subscriber 가 Publisher 에게 데이터를 요청하거나 구독을 취소하는 역할을 하는 인터페이스
                   - Backpressure
                     Subscriber 가 처리하는 데이터 양을 제한하는 요청방식. 

                     기존의 Push 방식과 반대로 Pull 방식을 이용해 자신이 처리할 데이터의 크기를 Publisher 에게
                     요청하는 것을 말함. 이를 통해 Subscriber 는 자신이 데이터를 처리할 준비가 되었을 때만
                     데이터를 요청할 수 있으며, 서버의 자원을 효율적으로 관리할 수 있게 됨.

                 - 리액티브 스트림을 구현한 라이브러리
                   RxJava
                   Reactor - JAVA 8
                   Akka Stream
                   vert.x
                   Project Reactor - JAVA 9
                   Kotlin Flow
                   JAVA 9 Flow API
                   Ratpack
                
                   Spring WebFlux 는 상기의 프로젝트중에서 Project Reactor 를 다시 이용해서 구현한 라이브러리임.

             - Netty( 참고로만 보세요 )
                 - 프로토콜 서버 및 클라이언트와 같은 네트워크 응요 프로그램을 빠르고 쉽게 개발할 수 있는
                   NIO( Non-Blocking Input/Output ) 클라이언트 서버 프레임워크임.
                 - TCP 및 UDP 소켓 서버와 같은 네트워크 프로그래밍을 많이 단순화하고 간소화하게 함.
                 - Netty 의 장점
                   1. 비동기 기반 네트워킹(Event Driven) 을 지원함.
                   2. Tomcat 서버가 10,000 건의 커넥션을 처리한다면, netty 는 NIO 방식으로 이벤트를 처리하기
                     때문에 자원이 스레드를 계속 점유하며, Block 상태를 유지 하지 않음.
                     따라서, 100,000 건에서 1,000,000 건의 커넥션을 처리할 수 있는 장점이 있음.
                   3. netty 의 경우에는 이벤트 기반 방식으로 동작하기 때문에 Tomcat 과 달리 
                     Thread Pool 의 Thread 개수는 머신의 Core 개수의 두 배임.
                   4. 스레드의 경합이 잘 일어나지 않음.


  8. 서비스 인증과 권한 부여
     8.1 보안과 관련된 책
         - 그림 설명으로 한번에 이해할 수 있는 보안의 기본, 위즈플래닛, 이영란 옮김.(178 page)
         - 스프링 시큐리티 인 액션, 위키북스( 600 page 정도 )
         - 클라우드X보안 실무 가이드, 프리렉( 500 page 정도 )
         - 마이크로 서비스 아키텍처(MSA) 보안 설계와 구현, 에이콘 출판사, ( 790 page 정도 )
           마이크로 시스템의 앱을 보호하는 기법에 대한 내용.
         - OWASP TOP 10
         - 정보보안 기사 -> 정보시스템 감리사 -> 기술사

     8.2 보안 취약성
         Spring Secutiry 를 적용하기 전에 애플리케이션의 취약성에 해당하는 공격점에 대해서 파악이 필요.

         - 취약점을 공부하기의 출발점으로 OWASP 프로젝트를 참조하면 좋음.
           OWASP 는 애플리케이션을 개발할 때 피해야 하는 가장 일반적인 취약성에 대한 자료가 많음.

         - 일반적인 취약성
           인증취약성
           세션 고정
           XSS(교차 스크립팅)
           CSRF(사이트 간 요청 위조)
           주입(Injection)
           기밀 데이터 노출
           메서드 접근 제어 부족
           알려진 취약성이 있는 종속성 이용

           위의 리스트는 스프링 시큐리티 사용과 직접 관련이 있음.

     8.3 인증과 권한
         - 인증은 애플리케이션이 이를 이용하려는 사람을 식별하는 프로세스를 말함.
         - 권한 부여는 인증된 호출자가 특정 기능과 데이터에 대한 이용 권리가 있는지 확인하는 프로세스임.

     8.4 세션 고정(Session Fixation)
         - 이 취약성이 존재하면 공격자는 이미 생성된 세션ID를 재이용해 유효한 사용자를 가장할 수 있음.
         - 예
           - 애플리케이션이 세션ID를 URL에 넣는경우 공격자는 피해자가 악성 링크를 클릭하도록 유인할 수 있음.
           - 애플리케이션이 세션 값을 쿠키에 저장하는 경우 공격자는 스크립트를 주입해 피해자의
             브라우저가 스크립트를 실행 할 수 있음. => XSS(교차 사이트 스크립트) 와 관련.

     8.5 교차 사이트 스크립트(XSS, Cross Site Scripting)
         - 서버에 노출된 웹 서비스로 클라이너트 쪽 스크립트르 주입해 다른 사용자가 이를 실행하도록 하는 공격임.
         - 이 취약성에 악용되면, 계정 가장(세션 고정) 이나 DDos 와 같은 분산 공격 등의 결과가 발생할 수 있음.
         - 예
           - 한 사용자가 웹 애플리케이션에서 메시지나 댓글을 게시함.
           - 메시지가 게시되면 해당 페이지를 방문하는 모든 사용자가 볼 수 있게 됨.
             사이트의 인기가 높으면 높을 수록 보안의 위험성이 높아짐.
           - 악성 댓글을 표시하는 페이지에 방문한 모든 사용자가 악성 스크립트를 실행하게 됨.
           - 사용자의 브라우저가 스크립트를 실행하고, 많은 양의 데이터를 게시하게 되거나, 
             많은 양의 데이터를 조회하게 됨. => 서비스가 정지할 정도가 되면, 서버는 다운이 되게 됨.

     8.6 CSRF(사이트 간 요청 위조, Cross Site Request Forgery)
         - 특정 서버에서 작업을 호출하는 URL을 추출해 애플리케이션 외부에서 재사용할 수 있음.
         - 특정 사용자를 대상으로 하지 않고, 불특정 다수를 대상으로 로그인된 사용자가
           자신의 의지와는 무관하게 공격자가 의도한 행위(수정, 삭제 등) 를 하게 만드는 공격임.
         - XSS 와 비슷하나, 좀 더 발전된 형태로 봄.
         - 예
           CSRF 공격을 이용하면 공격자는 특정 물품을 구매하여 장바구니에 넣어두고, 해당 물품에 대한
           결제를 다른 이를 통해 수행하게 됨.

     8.7 주입(Injection) 취약성
         - XSS도 주입 취약성의 하나로 볼 수 있음.
         - 주입 공격은 시스템에 피해를 가할 목적의 클라이언트 쪽 스크립트를 주입함.
         - SQL 주입, OS 명령어 주입 등
         - SQL 주입은 가장 오래되고 잘 알려진 주입 취약성임.
         - 예
           - 로그인 화면에서 로그인이 성공하면 일반적으로 해당 유저가 존재하면 로그인 성공으로 처리함.
           - 이런 경우 데이터베이스에서 SQL 을 사용하여 ID, PW 를 조건으로 등록된 유저를 검색함.
           - 검색 하는 SQL에 항상 데이터가 있도록 조건을 만들어서 로그인하게 함.
           - select user_id from member where user_id = 'hong' and pw = '1234'
             여기서 조건을 다음과 같이 되도록 함.
             where user_id = '' or '' = '' and pw = '' or '' = '' 
             그러면, 로그인 화면에서 ID 와 PW 입력 항목에 다음과 같이 입력한 후 로그인을 시도함.
             ID : ' or '' = '
             PW : ' or '' = '

     8.8 민감한 데이터의 노출
         - 애플리케이션의 동작과 관련된 데이터의 노출
           대표적으로 NullPointerException 이 발생하는 경우를 출력.
         - 예외 메시지에 IP 주소가 공개 노출
         - 예외 스택에 대한 정보 노출
           이 경우는 특정 작업에 이용되는 객체, 또한 객체간의 관계가 노출되게 됨.
           또는 더 심각한 문제는 애플리케이션이 이용하는 종속성의 버전 정보가 노출되는 경우임.
           이런 정보가 노출되면 해당 특정 버전의 취약성을 찾도록 하는 동기가 발생하게 됨.
           즉, 공격자를 시스템으로 초대하는 것이 될 수 있음.
         - 에러 메세지를 조합하여 실행 context를 분석할 수 있는 정보의 노출.

     8.9 메서드 접근 제어 부족
         - 애플리케이션 수준에도 한 계층에만 권한 부여를 적용하면 안됨.
           여기서 계층은 예를 들어, Controller, Service, Repository 임.
         - 예
           - 엔트포인트가 노출된 컨트롤러가 있음.
           - 이 컨트롤러는 일부 논리를 구현하고 리포지토리를 통해 영구 데이터를 이용하는 서비스를 호출함.
           - 여기서 컨트롤러 계층에만 권한 부여 구성을 적용.
           - 향후에 새로운 컨트롤러가 추가가 되는 경에 상기의 동일한 서비스를 사용하게 되면,
             추가된 새로운 컨트롤러에도 권한 부여 구성을 해야 함.
           - 따라서, 권한 부여 구성을 repository 로 이동하는 것이 더 좋음

     8.10 알려진 취약성이 있는 종속성 이용
         - 스프링 시큐리티와 직접적인 연관은 없지만, 애플리케이션 수준 보안의 중요한 부분임.
         - 대로 개발하는 애플리케이션이 아니라 기능을 만들기 위해 이용하는 라이브러리나 프레임워크 같은
           종속성에 취약성이 있을 수 있음.
           이용하는 종속성을 확인한 후 알려진 위약성이 있는 버전을 제거를 해야 함.

     8.11 토큰
         - 사무실에 들어갈 때 이용하는 출입 카드와 비슷하다고 보면 됨.
         - 방문자가 건물에 들어가면 먼저 접수대로 가서 신원을 밝히고 출입카드를 받아야 함.
         - 출입 카드가 있으면 건물의 일부 지역에 접근할 수 있지만, 모든 문을 열 수 있는 것은 아님.
         - 신원에 따라 허용된 문만 열 수 있으며, 나머지 문에는 접근할 수 없음.

         - 액세스 토큰도 마찬가지임.
         - 인증 후 토큰을 받고, 이를 바탕으로 이용 권리가 있는 리소스에 접근할 수 있음.
         - 토큰의 수명은 고정되고 일반적으로 오래 유지되지 않으며, 토큰이 만료되면 앱이 
           새로운 토큰을 받아야 함.
         - 서버는 필요한 경우 토큰의 만료 시간보다 일찍 토큰을 실격시킬 수 있음.

         - 토큰 사용시 장점.
           - 클라이언트는 사용자 자격 증명을 저장할 필요 없이 액세스 토큰과 
             최종적으로 갱신 토큰만 저장하면 됨.
           - 애플리케이션은 사용자 자격 증명을 (네트워크에) 노출하지 않게 됨.
           - 누군가가 토큰을 가로채면 사용자 자격 증명을 무효로 할 필요 없이 토큰을 실격시킬 수 있음.
           - 토큰을 이용하면 제삼자가 사용자를 가장하지 않고도 사용자 대신 리소스에 접근할 수 있으나,
             물론 이 경우 공격자가 토큰을 훔칠 수 도 있지만, 토큰은 일반적으로 수명이 제한되므로,
             이 취약성을 악용할 수 있는 기간도 제한된다.

         - 토큰을 저장하는 방법
           각 애플리케이션 디자인에 맞게 선택해서 사용.
           - 앱의 메모리에 토큰을 유지
           - 데이터베이스에 토큰을 유지
           - JWT(JSON 웹 토큰)을 통한 암호화 서명 사용


  9. Spring Security - 교재
     9.1 스프링 시큐리티
         - 애플리케이션의 인증, 인가 등의 보안 기능을 제공하는 스프링 하위 프로젝트 중 하나임.
         - 서블릿 필터를 기반으로 동작함.
         - 스프링 시큐리티를 사용하고자 하는 필터 체인을 서블릿 컨테이너의 필터 사이에서 동작시키기 위해서
           DelegationFilterProxy 를 사용함.
         - DelegationFilterProxy 는 서블릿 컨테이너의 생명주기와 스프링 애플리케이션 컨텍스트 사이에서
           다리 역할을 수행함.
         - DelegationFilterProxy 는 역할을 위임할 필터체인 프록시를 내부에 가지고 있음.
         - 필터체인 프록시(FilterChainProxy)는 스프링 시큐리티에서 제공하는 필터임.
           보안 필터체인을 통해 많은 다양한 보안 필터를 사용할 수 있음.
           필터 체인은 List 형식으로 다양한 보안 필터를 가질 수 있어 필요에 따라 선택적으로 사용하게 됨.

     9.2 스프링 시큐리티 폼 로그인 인증
         - UsernamePasswordAuthenticationFilter 를 통해 인증을 처리함.
         - UsernamePasswordAuthenticationFilter 는 SecurityFilterChain 에서 사용하는 Filter 임.
         - 처리 흐름은 교재의 378page 그림13.3 을 참고. 

     9.3 JWT를 이용한 로그인 인증
         - 교재의 실습 내용

         9.3.1 JWT
            - 당사자 간에 정보를 JSON 형태로 안전하게 전송하기 위한 토큰임.
              토큰에 대해서는 앞의 설명을 참조.
            - JWT는 URL 로 이용할 수 있는 문자열로만 구성.
            - 주로 서버와의 통신에서 권한 인가를 위해 사용됨.
            - JWT 는 헤더, 내용, 서명으로 구성되고, 각 부분을 점(.) 으로 구분함.


         9.3.2 스프링 시큐리티 인증 흐름

             클라인트의 요청 -> 인증 필터 <-> 인증 공급자 <-> 사용자 세부 정보 관리자 <->
             데이터베이스

             인증 필터 -> 보안 컨텍스트 -> 요청 처리

         9.3.3 스프링 시큐리티의 중요 구성 요소
             - 사용자 관리
               - 스프링 시큐리티에서 사용자를 기술하는 UserDetails
                 사용자명, 암호, 권한리스트, 계정만료, 계정장금, 자격 증명 만료, 계정 비활성화
               - 사용자가 실행할 수 있는 작업을 정의하는 GrantedAuthority
               - UserDetailsService 를 확장하는 UserDetailsManager. 상속된 동작외에
                 사용자 조회, 사용자 만들기, 사용자의 암호 수정, 사용자 삭제 등의 작업을 지원.

             - 사용자 인증
               - 흐름
                 인증 필터 -> 인증 관리자 <-> 인증 공급자 <-> 사용자 세부 정보 서비스 <-> DB

                 인증 필터 -> 보안 컨텍스트

               - 중요 구성 요소
                 - 주체(Principal, IF)
                   애플리케이션에서 접근을 요청하는 사용자.
                   인증하려는 사용자는 최소한 이름이 있어야 함.
                   
                 - 인증(Authentication, IF)
                   - Principal 에서 확장함.
                   - 주체, 인증 프로세스의 완료 여부, 권한의 컬렉션 등의 정보를 관리.
                   - 스프링 시큐리티에서 인증을 하려면, 사용자는 암호가 있어야 한다.
                   - 인증한 후에는 사용자가 이용할 수 있는 권한도 있어야 한다.
                   - 인증되었거나 진행중인 여부도 알 수 있어야 한다.

                - 보안 컨텍스트(Security Context)
                   - AuthenticationManager 가 인증 프로세스를 성공적으로 완료한 후
                     요청이 유지되는 동안 Authentication 인스턴스를 Security Context 에
                     저장한다.
                   - 따라서, Authentication(인증) 객체를 저장하는 인스턴스임.
                   - Security Context 를 관리하는 전략이 3 가지가 있음.
                     스레드 기반, 비동기 기반, 전용 기반이 있음.
                     일반적으로 스레드 기반을 사용함.

                     이 3가지 전략을 관리하는 역할을 하는 객체를 SecurityContextHolder 라고 함.
                   - 따라서, 인증이 완료된 Authentication 객체는 SecurityContextHolder 에서는
                     관리하게 됨. 인증이 완료된 Authentication 객체를 참조할 경우,
                     SecurityContextHolder 를 이용하면 됨.

                - 인증 예외 처리 Handler
                   - 인증이 성공한 경우의 Handler
                     AuthenticationSuccessHandler IF 를 구현해서 사용.
                   - 인증이 실패한 경우의 Handler
                     AuthenticationFailureHandler IF 를 구현해서 사용.

             - Security Configuration 설정
                  - WebSecurityConfigureAdapter 상속 받아서 사용.
                  - 설정하는 정보
                    리소스 접근 권한
                    인증 실패시 발생하는 예외처리
                    스프링 시큐리티 설정

  10. Spring Security - 교재 외
      10.1 진행방향
         - Spring Security Login Form 인증
           필터, 인증, 구조 파악
         - 보안 필터
         - 데이터베이스 연동
         - 인증(로그인), 인가(권한부여 및 체크)

      10.2 사용자 정의 인증 기능 구현( spring security login form 기반 )
         - 사용자 정의 보안 클래스 작성시,
           WebSecurityConfigureAdapter 를 상속 받고, configure() 오버라이드 해서 적용.
           스프링 시큐리티에서 제공하는 인증 및 인가 API를 HttpSecurity 를 사용해서 적용.

           인증 API : http.formLogin()
           인가 API : http.hasRole(ADMIN)

      10.2 Login Form 인증 흐름
           - 전체 웹 애플리케이션 구조
             user -> was(servlet container) -> spring security -> spring mvc

           - 인증 성공 흐름
            User Request -> UsernamePasswordAuthenticationFilter ->
            AntPathRequestMacher(/login) -> Authentication( Username + Password ) ->
            AuthenticationManager -> AuthenticationProvider(성공) -> Authentication ->
            SecurityContext -> SecurityContext 를 session에 저장 -> AuthenticationSuccessHandler

            다시 user 가 서버로 요청을 하면 ->
            spring security 는 현재 사용자가 가진 session 으로 부터 인증 토큰 객체의 존재 여부를 판단 ->
            토큰 객체가 존재하는 user 라면 해당 인증 토큰으로 인증이 유지가 되고,
            서버의 자원에 접근을 할 수 있게 됨.

            spring security 는 세션에 저장된 인증 토큰이 있다면, 그 사용자가 계속적으로 인증된
            사용자로 판단하고 인증을 유지하는 구조로 처리가 됨.

           - 인증 실패 흐름
            User Request -> UsernamePasswordAuthenticationFilter ->
            AntPathRequestMacher(/login) -> Authentication( Username + Password ) ->
            AuthenticationManager -> AuthenticationProvider(실패) -> AuthenticationException ->
            UsernamePasswordAuthenticationFilter

           - Break Point List
             UsernamePasswordAuthenticationFilter, 74, 81, 85 line
             AbstractAuthenticationProcessingFilter, 222, 227, 318, 319, 320, 321 line
             ProviderManager, 173, 182 line
             AbstractUserDetailsAuthenticationProvider, 124, 168, 196 line
             DaoAuthenticationProvider, 123 line
             WebSecurityConfigurerAdapter, 228, 238 line

      10.3 동시 세션 제어, 세션 고정 보호, 세션 정책
           - 동시 세션 제어
             최대 세션 허용 개수를 관리.( 하나의 세션으로 관리하는 목적 )
             예) 크롬 11번가 접속해서 로그인 후 쇼핑, 엣지 11번가 접속해서 로그인 후 쇼핑

             - 이전 사용자 세션
               API : http.maxSessionsPreventsLogin(false)
               사용자 1 이 먼저 서버에 로그인 => 세션이 생성됨.
               이후에 사용자 2 가 서버에 로그인 => 세션이 생성. 이전 사용자인 (사용자 1) 세션이 만료됨.
               사용자 1 은 세션이 만료가 됨.

             - 현재 사용자 세션
               API : http.maxSessionsPreventsLogin(true)
               사용자 1 이 먼저 서버에 로그인 => 세션이 생성됨.
               이후에 사용자 2가 서버에 로그인 => 인증 예외 발생.

           - 동시 세션 제어의 목적
              사용자, 공격자, 서버

              1. 공격자가 먼서 서버에 접속 => 세션이 생성됨. session_id = 1234
              2. 사용자가 공격자가 생성한 세션쿠키로 로그인 시도 => 로그인이 성공.
                 인증 단계를 거치지 않고 서버의 리소스를 사용할 수 있게 됨.
              3. 공격자가 사용자 정보를 공유해서 사용할 수 있게 됨.
              4. 공격자가 요청을 보내게 되면 사용자 정보로 사용할 수 있게 됨.

              => 동시 세션 제어를 설정해서 하나의 세션으로 관리하고, 매변 세션을 변경.
                 http.sessionManagement().sessionFixation().changeSessionId() // 기본값임.

      10.4 인가(권한 - 리소스(페이지) 접근 제한)
           - 선언적 방식 ( 코드로 권한 제어 )
             - URL
              HttpSecurity.antMatchers("/user/**").hasRole("USER")
             - Method
              @PreAuthorize("hasRole('USER')")
              public void user() { System.out.println("user") }

           - 동적 방식
             DB 에 권한을 관리
             - URL
             - Method

           - 인가 API
             permitAll() : 무조건 접근 허용.( 권한체크를 하지만, 권한이 없어도 됨. )
                           익명 권한.( 익명 인증 객체(null 객체, 익명 객체), 인증된 객체  )

                           권한체크 -> 해당하는 리소스에 접권 권한 부여.
                           리소스 종류( 서비스 : 인증 및 인가 대상, 그림파일 : 인증 인가 대상 제외 )
                                       그림파일 : 인증 인가 대상 제외 => Filter 를 사용하지 않도록 함.
                                                                    => 인증, 인가에 대한 비용 낮아짐.
             denyAll() : 무조건 접근을 허용하지 않음.
             anonumous() : 익명사용자의 접근을 허용.
             hasRole() : 주어진 역할이 있다면 접근을 허용.
             hasAuthority() : 주어진 권한이 있다면을 확인.
             hasIpAddress() : 주어진 IP로부터 요청이 왔다면 접근을 허용.

           - 인증 및 인가 예외 처리 흐름
             - 공통
               user request -> FilterSecurityInterceptor -> 인증 또는 인가 예외 발생.

             - 인가 예외
               인가 예외 발생 ->  ExceptionTranslationFilter -> AccessDeniedException ->
               AccessDeniedHandler() 처리 => response.redirect(/denied)

             - 인증 예외
               인증 예외 발생 -> ExceptionTranslationFilter -> AuthenticationException ->
               AuthenticationEntryPoint 처리 => response.redirect(/login)

           - 인증 및 인가 예외 처리 API
             - 인증 실패 처리 API
               HttpSecurity.exceptionHandling().authenticationEntryPoint()
               {AuthenticationEntryPoint 익명 클래스}

             - 인가 실패 처리 API
               HttpSecurity.exceptionHandling().accessDeniedHandler()
               {AccessDeniedHandler 익명 클래스}

      10.5 데이터베이스를 연동한 인증 및 인가 처리
        10.5.1 인증 구현 흐름
            1단계
            - inMemory~ API 를 사용해서 사용자를 생성함. => 사용하지 않음.
            - CustomUserDetailsService 생성.
            - AccountContext 생성.
            - SecurityConfig 반영.
            - 실행 및 디버깅

            2단계
            - 사용자 정의 인증 provider 생성.
              CustomAuthenticationProvider
              인증( 사용자명 조회 + 화면 입력 PW 와 DB PW 비교 ) -> 인가 -> 인증 토큰
            - SecurityConfig 반영.

            3단계
            - 사용자 정의 로그인 폼
            - 로그인 컨트롤러 생성
            - 서버 기동 및 테스트

            4단계
            - 로그아웃 방식은 두 가지임.
              - <form> 태그를 사용해서 POST 로 요청. => spring secutiry 의 logoutFilter 사용됨.
              - <a> 태그를 이용해서 GET 로 요청. => SecurityContextLogoutHandler 사용.

            - 사용자 정의 로그아웃 => GET 방식으로 만들어서 사용함.
               SecurityContextLogoutHandler 활용해서 구현하면 됨.

            - thymeleaf 를 사용하고 있으므로, spring security 의 문법을 지원하는 의존추가.
              thymeleaf 에서 spring security 의 문법(표현식)을 사용할 수 있게 됨.
              isAnonuymous(), isAuthenticated()

            - SecurityConfig  사용자 정의 로그인 페이지 설정.

            - 서버 기동 및 테스트


            5단계
            - 인증 성공에 대한 Handler 처리
            - spring security 에서 제공하는 메소드를 오버라이드해서 구현함.
              매개변수 request, response, 인증객체까지 받아서 사용할 수 있으므로,
              다양한 후속 처리가 가능해짐.
            - RequestCache(요청 캐쉬) 
              사용자가 요청한 경로에 대해서
              인증에 실패한 경우, 인증 처리 후 인증에 성공하게 되면,
              이동할 페이지로 인증 정에 요청한 경로로
              이동이 가능할 수 있도록 사용자의 요청 정보를 저장하고 있는 객체.


            6단계
            - 인증 실패에 대한 Handler  처리
            - SimpleUrlAuthenticationFailureHandler 상속 후, 
              onAuthenticationFailure() 를 오버라이드.
            - 오버라이드 내용.
              - AuthenticationException 의 유형이 BadCrentialsException 인지 확인.
                BadCrentialsException 은 CustomAuthenticationProvider 에서 throw 하는 예외임.
              - FailureUrl 설정
              - 필요한 설정 후 실제 나머지 처리는 부모에게 위임.
            - SecurityConfig 에 설정.


            7단계
            - 성공적으로 인증은 완료되었으나, 권한이 부족한 경우의 Handler 처리.
            - AccessDeniedHandler IF 를 구현. handler() 오버라이드.
            - SecurityConfig 에 설정.

              
        10.5.2 추가적으로 구현해야 할 부분 => 관리자 기능이 됨.
            - 리소스에 접근 권한 관리 기능을  DB 로 관리할 수 있게 구현.
              리소스와 리소스에 대한 권한 정보를 Map으로 관리하는 부분을 학습.
            - DB에 저장된 리소스 및 권한 정보를 spring security 의 Map 매핑하는 부분 학습.
              .antMatchers("/config").hasRole("ADMIN")

        10.5.3 OAuth(Open Authorization) + JWT

        10.5.4 보안의 기본 개념서 => Spring Security 의 관련 API 학습.














             





  
















            


           
            


 











           


             








